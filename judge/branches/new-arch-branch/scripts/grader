#!/usr/bin/ruby

def stop_grader
  File.open(File.dirname(__FILE__) + '/stop','w').close
end

def check_stopfile
  FileTest.exist?(File.dirname(__FILE__) + '/stop')
end

def clear_stopfile
  system("rm " + File.dirname(__FILE__) + '/stop')
end

def config
  Grader::Configuration.get_instance
end

def talk(str)
  if config.talkative
    puts str
  end
end

#########################################
# main program
#########################################

# reading environment and options
if (ARGV.length >= 1) and (ARGV[0]=='stop')
  stop_grader
  puts "stop file created"
  exit(0)
end

if check_stopfile
  puts "stop file exists"
  clear_stopfile
  exit(0)
end

grader_mode = 'queue'
if ARGV.length >= 1
  GRADER_ENV = ARGV[0]
  if ARGV.length >=2
    grader_mode = ARGV[1]
  end
else
  GRADER_ENV = 'exam'
end

puts "environment: #{GRADER_ENV}"
require File.join(File.dirname(__FILE__),'config/environment')

#reading rails environment
talk 'Reading rails environment'

RAILS_ENV = config.rails_env
require RAILS_ROOT + '/config/environment'


#register grader process
if config.report_grader
  grader_proc = GraderProcess.register(config.grader_hostname,
                                       Process.pid,
                                       grader_mode)
else
  grader_proc = nil
end

# create judge engine
engine = Grader::Engine.new(grader_proc)

case grader_mode
when "queue"
  talk 'Grader queue'
  while true
    
    if check_stopfile    # created by calling grader stop
      clear_stopfile
      puts "stopped"
      break
    end

    task = engine.grade_oldest_task
    if task==nil
      sleep(5)
    end
  end
  
when "prob"

  grader_proc.report_active if grader_proc!=nil

  prob = Problem.find_by_name(ARGV[2])
  if prob==nil
    puts "cannot find problem: #{ARGV[2]}"
  else
    engine.grade_problem(prob)
  end
  
end

# report inactive
grader_proc.report_inactive if grader_proc!=nil
                             
